# Building out the Back End

In this session, we'll add the rest of our models and controllers that expose them. We'll also refactor our application, moving our DTOs to a shared project so they can be used by our front-end application later.

## Add a ConferenceDTO project

We'll start by creating the new shared project to hold our data transfer objects.

### Adding the ConferenceDTO Project using Visual Studio

1. If using Visual Studio, right-click on the Solution and select *Add* / *New Project...*.
1. Select *Class Library* from the project type, name the project ConferenceDTO and press OK.
![Creating a DTO project in Visual Studio](images/vs-create-dto-project.png)
1. Delete the generated `Class1.cs` file from this new project.
1. Right-click the 'Dependencies' node under the *BackEnd* project, select *Add* / *Project Reference* and put a checkmark near ConferenceDTO.

### Adding the ConferenceDTO project via the Command Line

1. Open a command prompt and navigate to the root `ConferencePlanner` directory.
1. Run the following command:

   ```bash
   dotnet new classlib -o ConferenceDTO
   ```

1. Next we'll need to add a reference to the ConferenceDTO project from the BackEnd project. From the command line, navigate to the BackEnd project directory and execute the following command:

   ```bash
   dotnet add reference ../ConferenceDTO
   ```

1. Add the ConferenceDTO project to the solution:

   ```bash
   dotnet sln add ConferenceDTO/ConferenceDTO.csproj
   ```

## Refactoring the Speaker model into the ConferenceDTO project

1. Copy the `Speaker.cs` class from the *BackEnd* application into the root of the new ConferenceDTO project, and change the namespace from `Backend.Models` to `ConferenceDTO`.
1. Go back to the *BackEnd* application and modify the code in `Speaker.cs` as shown:

   ```csharp
   namespace BackEnd.Models;

   public class Speaker : ConferenceDTO.Speaker
   {
   }
   ```

1. Run the application and view the Speakers data using the Swagger UI to verify everything still works.

## Adding the remaining models to ConferenceDTO

We've got several more models to add, and unfortunately it's a little mechanical. You can copy the following classes manually, or open the completed solution which is shown at the end.

1. Create an `Attendee.cs` class in the *ConferenceDTO* project with the following code:

   ```csharp
   using System.ComponentModel.DataAnnotations;
   
   namespace ConferenceDTO;
   
   public class Attendee
   {
       public int Id { get; set; }
   
       [Required]
       [StringLength(200)]
       public virtual string? FirstName { get; set; }
   
       [Required]
       [StringLength(200)]
       public virtual string? LastName { get; set; }
   
       [Required]
       [StringLength(200)]
       public string? UserName { get; set; }
   
       [StringLength(256)]
       public virtual string? EmailAddress { get; set; }
   }
   ```

1. Create a `Session.cs` class with the following code:

   ```csharp
   using System.ComponentModel.DataAnnotations;
   
   namespace ConferenceDTO;
   
   public class Session
   {
       public int Id { get; set; }
   
       [Required]
       [StringLength(200)]
       public string? Title { get; set; }
   
       [StringLength(4000)]
       public virtual string? Abstract { get; set; }
   
       public virtual DateTimeOffset? StartTime { get; set; }
   
       public virtual DateTimeOffset? EndTime { get; set; }
   
       // Bonus points to those who can figure out why this is written    this way
       public TimeSpan Duration => EndTime?.Subtract(StartTime ?? EndTime ?? DateTimeOffset.MinValue) ?? TimeSpan.Zero;
   
       public int? TrackId { get; set; }
   }
   ```

1. Create a new `Track.cs` class with the following code:

   ```csharp
   using System.ComponentModel.DataAnnotations;
   
   namespace ConferenceDTO;
   public class Track
   {
       public int Id { get; set; }
   
       [Required]
       [StringLength(200)]
       public string? Name { get; set; }
   }
   ```

## Creating Derived Models in the BackEnd project

We're not going to create our EF models directly from the `ConferenceDTO` classes. Instead, we'll create some composite classes such as `SessionSpeaker`, since these will map more closely to what our application will be working with.

We're also going to take this opportunity to rename the `Models` directory in the *BackEnd* project to `Data` since it no longer just contains models.

1. Right-click the `Models` directory and select `Rename`, changing the name to `Data`. Change the namespace for both `ApplicationDbContext` and `Speaker` to `Backend.Data`.
    > Note: If you are using Visual Studio, you can use refactoring to rename the namespace.
1. Add a `SessionSpeaker.cs` class to the `BackEnd` project's `Data` directory with the following code:

   ```csharp
    namespace BackEnd.Data;
    
    public class SessionSpeaker
    {
        public int SessionId { get; set; }
    
        public Session Session { get; set; } = null!;
    
        public int SpeakerId { get; set; }
    
        public Speaker Speaker { get; set; } = null!;
    }
   ```

1. Add an `SessionAttendee.cs` class to the `BackEnd` project's `Data` directory with the following code:

   ```csharp
    namespace BackEnd.Data;
    
    public class SessionAttendee
    {
        public int SessionId { get; set; }
    
        public Session Session { get; set; } = null!;
    
        public int AttendeeId { get; set; }
    
        public Attendee Attendee { get; set; } = null!;
    }
   ```

1. Add an `Attendee.cs` class to the `BackEnd` project's `Data` directory with the following code:

   ```csharp
    namespace BackEnd.Data;
    
    public class Attendee : ConferenceDTO.Attendee
    {
        public virtual ICollection<SessionAttendee> SessionsAttendees { get; set; } = null!;
    }
   ```

1. Add a `Session.cs` class to the `BackEnd` project's `Data` directory with the following code:

   ```csharp
   using System;
   using System.Collections;
   using System.Collections.Generic;
   
   namespace BackEnd.Data
   {
       public class Session : ConferenceDTO.Session
       {
           public virtual ICollection<SessionSpeaker> SessionSpeakers { get; set; } = null!;

           public virtual ICollection<SessionAttendee> SessionAttendees { get; set; } = null!;
   
           public Track Track { get; set; }
       }
   }
   ```

1. Add a `Track.cs` class to the `BackEnd` project's `Data` directory with the following code:

   ```csharp
    namespace BackEnd.Data;
    
    public class Track : ConferenceDTO.Track
    {
        public virtual ICollection<Session> Sessions { get; set; } = null!;
    }
   ```

1. Modify the `Speaker.cs` class we wrote previously to make the following two changes: update to the namespace to match our directory rename (if not already done), and add a reference to the `SessionSpeaker` composite class:

   ```csharp
    namespace BackEnd.Data;
    
    public class Speaker : ConferenceDTO.Speaker
    {
        public virtual ICollection<SessionSpeaker> SessionSpeakers { get; set; } = new List<SessionSpeaker>();
    }
   ```

## Update the ApplicationDbContext

Okay, now we need to update our `ApplicationDbContext` so Entity Framework knows about our new models.

1. Update `ApplicationDbContext.cs` to use the following code:

   ```csharp
    using Microsoft.EntityFrameworkCore;
    
    namespace BackEnd.Data;
    
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }
    
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Attendee>()
            .HasIndex(a => a.UserName)
            .IsUnique();
    
            // Many-to-many: Session <-> Attendee
            modelBuilder.Entity<SessionAttendee>()
                .HasKey(ca => new { ca.SessionId, ca.AttendeeId });
    
            // Many-to-many: Speaker <-> Session
            modelBuilder.Entity<SessionSpeaker>()
                .HasKey(ss => new { ss.SessionId, ss.SpeakerId });
        }
    
        public DbSet<Session> Sessions => Set<Session>();
    
        public DbSet<Track> Tracks => Set<Track>();
    
        public DbSet<Speaker> Speakers => Set<Speaker>();
    
        public DbSet<Attendee> Attendees => Set<Attendee>();
    }
   ```

1. Fix errors due to the rename from `BackEnd.Models` to `BackEnd.Data`. You can either do this using a find / replace (replacing "BackEnd.Models" with "BackEnd.Data") or you can do a build and fix errors.
1. Ensure that the application builds now.

## Add a new database migration

### Visual Studio: Package Manager Console

1. Run the following commands in the Package Manager Console (specify the `BackEnd` project)

   ```bash
   Add-Migration Refactor
   Update-Database
   ```

### Command line

1. Run the following commands in the command prompt in the `BackEnd` project directory:

   ```bash
   dotnet ef migrations add Refactor
   dotnet ef database update
   ```

1. Now take a deep breath and run the application and navigate to `/swagger`. Hopefully, you should see the Swagger UI. There are no new endpoints, but you will see some new types listed in the Schemas section (e.g. `Session`, `Track`, `Speaker`, etc.).

## Updating the Speakers API controller

Now that we've added our new models, we can update our `Speakers` API endpoints to include richer information, which will simplify building our UI by removing the need to make a lot of separate requests. When we display the list of speakers, we're going to want to include the sessions they are presenting. We can do this by updating our EF query to use the [many-to-many navigation properties](https://docs.microsoft.com/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key#many-to-many) we've added to our models.

1. As a first step, we can modify the first route in our `SpeakerEndpoints` class as shown below:

   ```csharp
    routes.MapGet("/api/Speaker", async (ApplicationDbContext db) =>
    {
        var speakers = await db.Speakers.AsNoTracking()
                                    .Include(s => s.SessionSpeakers)
                                    .ThenInclude(ss => ss.Session)
                                    .ToListAsync();
        return speakers;
    })
    .WithTags("Speaker")
    .WithName("GetAllSpeakers")
    .Produces<List<Speaker>>(StatusCodes.Status200OK);
   ```

1. While the above will work, this is directly returning our model class. A better practice is to return an output model class. Create a `SpeakerResponse.cs` class in the `ConferenceDTO` project with the following code:

   ```csharp
    namespace ConferenceDTO;
    public class SpeakerResponse : Speaker
    {
        public ICollection<Session> Sessions { get; set; } = new List<Session>();
    }
   ```

1. Now we'll add a utility method to map between these classes. In the *BackEnd* project, create an `Infrastructure` directory. Add a class named `EntityExtensions.cs` with the following mapping code:

   ```csharp
    using BackEnd.Data;
    
    namespace BackEnd.Infrastructure;
    
    public static class EntityExtensions
    {
        public static ConferenceDTO.SpeakerResponse MapSpeakerResponse(this Speaker speaker) =>
            new ConferenceDTO.SpeakerResponse
            {
                Id = speaker.Id,
                Name = speaker.Name,
                Bio = speaker.Bio,
                WebSite = speaker.WebSite,
                Sessions = speaker.SessionSpeakers?
                    .Select(ss =>
                        new ConferenceDTO.Session
                        {
                            Id = ss.SessionId,
                            Title = ss.Session.Title
                        })
                    .ToList() ?? new()
            };
    }
   ```

Now we can update the `GetSpeakers()` method of the *SpeakersEndpoints* so that it returns our response model.

1. Add a using statement to `SpeakersEndpoints.cs`: `using BackEnd.Infrastructure;`

1. Update the `/api/Speaker` endpoint method so that it reads as follows:

   ```csharp
    routes.MapGet("/api/Speaker", async (ApplicationDbContext db) =>
    {
        var speakers = await db.Speakers.AsNoTracking()
                                        .Include(s => s.SessionSpeakers)
                                            .ThenInclude(ss => ss.Session)
                                        .Select(s => s.MapSpeakerResponse())
                                        .ToListAsync();
        return speakers;
    })
    .WithTags("Speaker")
    .WithName("GetAllSpeakers")
    .Produces<List<Speaker>>(StatusCodes.Status200OK);
   ```

1. Update the route for `/api/Speaker/{id}` to use our mapped response models as follows:

   ```csharp
    routes.MapGet("/api/Speaker/{id}", async (int Id, ApplicationDbContext db) =>
    {
        var speaker = await db.Speakers.AsNoTracking()
                            .Include(s => s.SessionSpeakers)
                                .ThenInclude(ss => ss.Session)
                            .SingleOrDefaultAsync(s => s.Id == Id);

        return speaker
            is Speaker model
                ? Results.Ok(model)
                : Results.NotFound();
    })
    .WithTags("Speaker")
    .WithName("GetSpeakerById")
    .Produces<Speaker>(StatusCodes.Status200OK)
    .Produces(StatusCodes.Status404NotFound);
   ```

1. Remove the other routes (`MapPut`, `MapPost`, `MapDelete`), on the `SpeakersEndpoints`. We will be loading our speakers from a JSON file into our database, so we don't need to support these actions. This is a good concept to keep in mind when you're working with a REST API: only expose the actions that you want to allow.

## Adding the remaining API Controllers and DTOs

1. Add the following response DTO classes from [the save point folder](/save-points/2-BackEnd-completed/ConferencePlanner/ConferenceDTO)
   - `AttendeeResponse`
   - `SessionResponse`
1. Update the `EntityExtensions` class with the `MapSessionResponse` and `MapAttendeeResponse` methods from [the save point folder](/save-points/2-BackEnd-completed/ConferencePlanner/BackEnd/Infrastructure)
1. Copy the following controllers from [the save point folder](/save-points/2-BackEnd-completed/ConferencePlanner/BackEnd/Controllers) into the current project's `BackEnd/Controllers` directory:
   - `SessionsController`
   - `AttendeesController`

## Adding Conference Upload support

1. Copy the `DataLoader.cs` class from [here](/src/BackEnd/Data/DataLoader.cs) into the `Data` directory of the `BackEnd` project.
1. Copy the `SessionizeLoader.cs` and `DevIntersectionLoader.cs` classes from [here](/src/BackEnd/Data/) into the current project's `/src/BackEnd/Data/` directory.
    > Note: We have data loaders from the two conference series where this workshop has been presented most; you can update this to plug in your own conference file format.
1. To improve the UI for upload, add a converter to the JSON serializer options to map enums to strings by changing `AddControllers()` in `Startup.cs` to the following:

    ```c#
    services.AddControllers()
            .AddJsonOptions(options =>
            {
                options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
            });
    ```

1. Run the application to see the updated data via Swagger UI.
1. Use the Swagger UI to upload [NDC_London_2020.json](/src/BackEnd/Data/Import/NDC_London_2020.json) to the `/api/Sessions/upload` API.

**Next**: [Session #3 - Front-end](3.%20Add%20front-end%2C%20render%20agenda%2C%20set%20up%20front-end%20models.md) | **Previous**: [Session #1 - Setup, basic EF model](/docs/1.%20Create%20BackEnd%20API%20project.md)
